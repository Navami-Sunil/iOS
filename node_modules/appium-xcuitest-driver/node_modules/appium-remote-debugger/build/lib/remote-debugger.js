"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteDebugger = exports.RPC_RESPONSE_TIMEOUT_MS = exports.REMOTE_DEBUGGER_PORT = void 0;
const events_1 = require("events");
const logger_1 = __importDefault(require("./logger"));
const rpc_1 = require("./rpc");
const utils_1 = require("./utils");
const connectMixins = __importStar(require("./mixins/connect"));
const executeMixins = __importStar(require("./mixins/execute"));
const messageHandlerMixins = __importStar(require("./mixins/message-handlers"));
const navigationMixins = __importStar(require("./mixins/navigate"));
const cookieMixins = __importStar(require("./mixins/cookies"));
const screenshotMixins = __importStar(require("./mixins/screenshot"));
const eventMixins = __importStar(require("./mixins/events"));
const miscellaneousMixins = __importStar(require("./mixins/misc"));
const lodash_1 = __importDefault(require("lodash"));
const async_lock_1 = __importDefault(require("async-lock"));
exports.REMOTE_DEBUGGER_PORT = 27753;
/* How many milliseconds to wait for webkit to return a response before timing out */
exports.RPC_RESPONSE_TIMEOUT_MS = 5000;
const PAGE_READY_TIMEOUT_MS = 5000;
const { version: MODULE_VERSION } = (0, utils_1.getModuleProperties)();
class RemoteDebugger extends events_1.EventEmitter {
    /**
     * @param {RemoteDebuggerOptions} opts
     */
    constructor(opts = {}) {
        super();
        // methods
        this.setConnectionKey = connectMixins.setConnectionKey;
        this.disconnect = connectMixins.disconnect;
        this.searchForApp = connectMixins.searchForApp;
        this.searchForPage = connectMixins.searchForPage;
        this.checkPageIsReady = navigationMixins.checkPageIsReady;
        this.cancelPageLoad = navigationMixins.cancelPageLoad;
        this.waitForDom = navigationMixins.waitForDom;
        this.execute = executeMixins.execute;
        this.executeAtom = executeMixins.executeAtom;
        this.executeAtomAsync = executeMixins.executeAtomAsync;
        this.isPageLoadingCompleted = navigationMixins.isPageLoadingCompleted;
        this.selectApp = connectMixins.selectApp;
        this.connect = connectMixins.connect;
        this.selectPage = connectMixins.selectPage;
        this.navToUrl = navigationMixins.navToUrl;
        this.getCookies = cookieMixins.getCookies;
        this.setCookie = cookieMixins.setCookie;
        this.deleteCookie = cookieMixins.deleteCookie;
        this.captureScreenshot = screenshotMixins.captureScreenshot;
        this.addClientEventListener = eventMixins.addClientEventListener;
        this.removeClientEventListener = eventMixins.removeClientEventListener;
        this.launchSafari = miscellaneousMixins.launchSafari;
        this.startTimeline = miscellaneousMixins.startTimeline;
        this.stopTimeline = miscellaneousMixins.stopTimeline;
        this.startConsole = miscellaneousMixins.startConsole;
        this.stopConsole = miscellaneousMixins.stopConsole;
        this.startNetwork = miscellaneousMixins.startNetwork;
        this.stopNetwork = miscellaneousMixins.stopNetwork;
        this.overrideUserAgent = miscellaneousMixins.overrideUserAgent;
        this.garbageCollect = miscellaneousMixins.garbageCollect;
        // Callbacks
        this.onPageChange = messageHandlerMixins.onPageChange;
        this.onConnectedApplicationList = messageHandlerMixins.onConnectedApplicationList;
        this.onAppConnect = messageHandlerMixins.onAppConnect;
        this.onAppDisconnect = messageHandlerMixins.onAppDisconnect;
        this.onAppUpdate = messageHandlerMixins.onAppUpdate;
        this.onConnectedDriverList = messageHandlerMixins.onConnectedDriverList;
        this.onCurrentState = messageHandlerMixins.onCurrentState;
        this.frameDetached = navigationMixins.frameDetached;
        // @ts-ignore This is OK
        this._log = opts.log ?? logger_1.default;
        this.log.info(`Remote Debugger version ${MODULE_VERSION}`);
        const { bundleId, additionalBundleIds = [], platformVersion, isSafari = true, includeSafari = false, useNewSafari = false, pageLoadMs, host, port = exports.REMOTE_DEBUGGER_PORT, socketPath, pageReadyTimeout = PAGE_READY_TIMEOUT_MS, remoteDebugProxy, garbageCollectOnExecute = false, logFullResponse = false, logAllCommunication = false, logAllCommunicationHexDump = false, webInspectorMaxFrameLength, socketChunkSize, fullPageInitialization, pageLoadStrategy, } = opts;
        this.bundleId = bundleId;
        this.additionalBundleIds = additionalBundleIds;
        this.platformVersion = platformVersion;
        this.isSafari = isSafari;
        this.includeSafari = includeSafari;
        this.useNewSafari = useNewSafari;
        this.pageLoadMs = pageLoadMs;
        this.log.debug(`useNewSafari --> ${this.useNewSafari}`);
        this.garbageCollectOnExecute = garbageCollectOnExecute;
        this.host = host;
        this.port = port;
        this.socketPath = socketPath;
        this.remoteDebugProxy = remoteDebugProxy;
        this.pageReadyTimeout = pageReadyTimeout;
        this.logAllCommunication = lodash_1.default.isNil(logAllCommunication) ? !!logFullResponse : !!logAllCommunication;
        this.logAllCommunicationHexDump = logAllCommunicationHexDump;
        this.socketChunkSize = socketChunkSize;
        if (lodash_1.default.isInteger(webInspectorMaxFrameLength)) {
            this.webInspectorMaxFrameLength = webInspectorMaxFrameLength;
        }
        this.fullPageInitialization = fullPageInitialization;
        this.pageLoadStrategy = pageLoadStrategy;
        this._lock = new async_lock_1.default();
    }
    /**
     * @returns {import('@appium/types').AppiumLogger}
     */
    get log() {
        return this._log;
    }
    /**
     * @param {boolean} [checkConnected=false]
     * @returns {import('./rpc/rpc-client').RpcClient}
     */
    requireRpcClient(checkConnected = false) {
        if (!this.rpcClient) {
            throw new Error(`rpcClient is undefined. Has 'initRpcClient' been called before?`);
        }
        if (checkConnected && !this.rpcClient.isConnected) {
            throw new Error('Remote debugger is not connected');
        }
        return this.rpcClient;
    }
    /**
     * @returns {void}
     */
    setup() {
        // app handling configuration
        this.appDict = {};
        this.appIdKey = null;
        this.pageIdKey = null;
        this.pageLoading = false;
        this._navigatingToPage = false;
        this.allowNavigationWithoutReload = false;
        this.rpcClient = null;
        this._clientEventListeners = {};
    }
    /**
     * @returns {void}
     */
    teardown() {
        this.log.debug('Cleaning up listeners');
        this.appDict = {};
        this.appIdKey = null;
        this.pageIdKey = null;
        this.pageLoading = false;
        this.rpcClient = null;
        this.removeAllListeners(RemoteDebugger.EVENT_PAGE_CHANGE);
        this.removeAllListeners(RemoteDebugger.EVENT_DISCONNECT);
    }
    /**
     * @returns {void}
     */
    initRpcClient() {
        this.rpcClient = new rpc_1.RpcClientSimulator({
            bundleId: this.bundleId,
            platformVersion: this.platformVersion,
            isSafari: this.isSafari,
            host: this.host,
            port: this.port,
            socketPath: this.socketPath,
            messageProxy: this.remoteDebugProxy,
            logAllCommunication: this.logAllCommunication,
            logAllCommunicationHexDump: this.logAllCommunicationHexDump,
            fullPageInitialization: this.fullPageInitialization,
            webInspectorMaxFrameLength: this.webInspectorMaxFrameLength,
        });
    }
    /**
     * @returns {boolean}
     */
    get isConnected() {
        return !!this.rpcClient?.isConnected;
    }
    /**
     * @param {boolean} allow
     */
    set allowNavigationWithoutReload(allow) {
        this._allowNavigationWithoutReload = allow;
    }
    /**
     * @returns {boolean}
     */
    get allowNavigationWithoutReload() {
        return !!this._allowNavigationWithoutReload;
    }
    /**
     * @returns {string[]}
     */
    get skippedApps() {
        return this._skippedApps ?? [];
    }
}
exports.RemoteDebugger = RemoteDebugger;
for (const [name, event] of lodash_1.default.toPairs(eventMixins.events)) {
    RemoteDebugger[name] = event;
}
exports.default = RemoteDebugger;
/**
 * @typedef {Object} RemoteDebuggerOptions
 * @property {string} [bundleId] id of the app being connected to
 * @property {string[]} [additionalBundleIds=[]] array of possible bundle
 *                      ids that the inspector could return
 * @property {string} [platformVersion] version of iOS
 * @property {boolean} [isSafari=true]
 * @property {boolean} [includeSafari=false]
 * @property {boolean} [useNewSafari=false] for web inspector, whether this is a new Safari instance
 * @property {number} [pageLoadMs] the time, in ms, that should be waited for page loading
 * @property {string} [host] the remote debugger's host address
 * @property {number} [port=REMOTE_DEBUGGER_PORT] the remote debugger port through which to communicate
 * @property {string} [socketPath]
 * @property {number} [pageReadyTimeout=PAGE_READY_TIMEOUT]
 * @property {string} [remoteDebugProxy]
 * @property {boolean} [garbageCollectOnExecute=false]
 * @property {boolean} [logFullResponse=false]
 * @property {boolean} [logAllCommunication=false] log plists sent and received from Web Inspector
 * @property {boolean} [logAllCommunicationHexDump=false] log communication from Web Inspector as hex dump
 * @property {number} [webInspectorMaxFrameLength] The maximum size in bytes of a single data
 *                    frame in the device communication protocol
 * @property {number} [socketChunkSize] size, in bytes, of chunks of data sent to
 *                    Web Inspector (real device only)
 * @property {boolean} [fullPageInitialization]
 * @property {string} [pageLoadStrategy]
 * @property {import('@appium/types').AppiumLogger} [log]
 */
//# sourceMappingURL=remote-debugger.js.map